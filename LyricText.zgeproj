<?xml version="1.0" encoding="iso-8859-1" ?>
<ZApplication Name="App" Caption="HUD Line" ClearColor="0 0 0 1" AmbientLightColor="0.7529 0.7529 0.7529 1" ScreenMode="0" CameraPosition="0 0 30" LightPosition="200 200 200" ViewportRatio="2" FOV="70" ClipFar="1000" MouseVisible="255" UseStencilBuffer="255" FileVersion="2">
  <Comment>
<![CDATA[Lyric Text

This is heavily based off Rado1's HUD Text and uses his ZgeNanoVG
 library.  It is intended to greatly simplify scripting text animations for 
lyric-style videos.

You'll need to automate the "Text line" control to pick lyrics from the
"Add content->Text" page in ZGE Visualizer.

When the text changes, it starts an Attack, which lasts for the
specified length (the slider is a multiplier on beats).

After the attack effect, it goes to hold, then to release.

On top of the A/H/R effects, the Beat FX will be applied if one
is selected.]]>
  </Comment>
  <OnLoaded>
    <ZExternalLibrary Comment="Vector graphics library" ModuleName="ZgeNano" CallingConvention="1">
      <Source>
<![CDATA[/*
  ZgeNano Library; vector graphics rendering library
  build on NanoVG: https://github.com/memononen/nanovg
  and NanoSVG: https://github.com/memononen/nanosvg

  Version: 1.4 (2018-09-10)

  Download Windows DLL and Android shared library from
  https://github.com/Rado-1/ZgeNano/releases

  Project home
  https://github.com/Rado-1/ZgeNano

  Copyright (c) 2016-2018 Radovan Cervenka
*/

// init flags
const int
  NVG_ANTIALIAS = 1<<0,
	NVG_STENCIL_STROKES = 1<<1,
	NVG_DEBUG = 1<<2;

// winding (direction of arcs)
const int
  NVG_CCW = 1, // counter-clockwise
  NVG_CW = 2; // clockwise

// solidity
const int
  NVG_SOLID = 1,
	NVG_HOLE = 2;

// line caps
const int
	NVG_BUTT = 0,
	NVG_ROUND = 1,
	NVG_SQUARE = 2,
	NVG_BEVEL = 3,
	NVG_MITER = 4;

// align
const int
	// Horizontal align
	NVG_ALIGN_LEFT 		= 1<<0,	// Default, align text horizontally to left.
	NVG_ALIGN_CENTER 	= 1<<1,	// Align text horizontally to center.
	NVG_ALIGN_RIGHT 	= 1<<2,	// Align text horizontally to right.
	// Vertical align
	NVG_ALIGN_TOP 		= 1<<3,	// Align text vertically to top.
	NVG_ALIGN_MIDDLE	= 1<<4,	// Align text vertically to middle.
	NVG_ALIGN_BOTTOM	= 1<<5,	// Align text vertically to bottom.
	NVG_ALIGN_BASELINE	= 1<<6; // Default, align text vertically to baseline.

// blend factor
const int
	NVG_ZERO = 1<<0,
	NVG_ONE = 1<<1,
	NVG_SRC_COLOR = 1<<2,
	NVG_ONE_MINUS_SRC_COLOR = 1<<3,
	NVG_DST_COLOR = 1<<4,
	NVG_ONE_MINUS_DST_COLOR = 1<<5,
	NVG_SRC_ALPHA = 1<<6,
	NVG_ONE_MINUS_SRC_ALPHA = 1<<7,
	NVG_DST_ALPHA = 1<<8,
	NVG_ONE_MINUS_DST_ALPHA = 1<<9,
	NVG_SRC_ALPHA_SATURATE = 1<<10;

// composite operation
const int
	NVG_SOURCE_OVER = 0,
	NVG_SOURCE_IN = 1,
	NVG_SOURCE_OUT = 2,
	NVG_ATOP = 3,
	NVG_DESTINATION_OVER = 4,
	NVG_DESTINATION_IN = 5,
	NVG_DESTINATION_OUT = 6,
	NVG_DESTINATION_ATOP = 7,
	NVG_LIGHTER = 8,
	NVG_COPY = 9,
	NVG_XOR = 10;

// image flags
const int
  NVG_IMAGE_GENERATE_MIPMAPS	= 1<<0,     // Generate mipmaps during creation of the image.
	NVG_IMAGE_REPEATX			= 1<<1,		// Repeat image in X direction.
	NVG_IMAGE_REPEATY			= 1<<2,		// Repeat image in Y direction.
	NVG_IMAGE_FLIPY				= 1<<3,		// Flips (inverses) image in Y direction when rendered.
	NVG_IMAGE_PREMULTIPLIED		= 1<<4;		// Image data has premultiplied alpha.

// Init
xptr nvg_Init(int flags) {} // Returns NanoVG context used in other functions.
void nvg_SetContext(xptr context) {}
void nvg_Finish(xptr context) {}
int nvg_SetViewport(xptr context) {} // Returns 1 if changed viewport, 0 otherwise.

// Drawing
void nvg_BeginFrame() {}
void nvg_CancelFrame() {}
void nvg_EndFrame() {}

// Global composite operation
void nvg_GlobalCompositeOperation(int op) {}
void nvg_GlobalCompositeBlendFunc(int sfactor, int dfactor) {}
void nvg_GlobalCompositeBlendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {}

// State handling
void nvg_Save() {}
void nvg_Restore() {}
void nvg_Reset() {}

// Render styles
void nvg_StrokeColor(float r, float g, float b, float a) {}
void nvg_StrokePaint(xptr paint) {} // paint - result of Paints functions
void nvg_FillColor(float r, float g, float b, float a) {}
void nvg_FillPaint(xptr paint) {} // paint - result of Paints functions
void nvg_MiterLimit(float limit) {}
void nvg_StrokeWidth(float size) {}
void nvg_LineCap(int cap) {}
void nvg_LineJoin(int join) {}
void nvg_GlobalAlpha(float alpha) {}

// Transformations
void nvg_ResetTransform() {}
void nvg_Transform(float a, float b, float c, float d, float e, float f) {}
void nvg_Translate(float x, float y) {}
void nvg_Rotate(float angle) {}
void nvg_SkewX(float angle) {}
void nvg_SkewY(float angle) {}
void nvg_Scale(float x, float y) {}

// Images
int nvg_CreateImage(string filename, int imageFlags) {}
int nvg_CreateImageMem(int imageFlags, xptr data, int ndata) {}
int nvg_CreateImageRGBA(int w, int h, int imageFlags, xptr data) {}
void nvg_UpdateImage(int image, xptr data) {}
void nvg_ImageSize(int image, ref int w, ref int h) {}
void nvg_DeleteImage(int image) {}

// Paints
xptr nvg_LinearGradient(float sx, float sy, float ex, float ey,
	float ir, float ig, float ib, float ia,
	float or, float og, float ob, float oa) {}
xptr nvg_BoxGradient(float x, float y, float w, float h, float r, float f,
	float ir, float ig, float ib, float ia,
	float or, float og, float ob, float oa) {}
xptr nvg_RadialGradient(float cx, float cy, float inr, float outr,
	float ir, float ig, float ib, float ia,
	float or, float og, float ob, float oa) {}
xptr nvg_ImagePattern(float ox, float oy, float ex, float ey,
	float angle, int image, float alpha) {}
void nvg_FreePaint(xptr paint) {}

// Scissoring
void nvg_Scissor(float x, float y, float w, float h) {}
void nvg_IntersectScissor(float x, float y, float w, float h) {}
void nvg_ResetScissor() {}

// Paths
void nvg_BeginPath() {}
void nvg_MoveTo(float x, float y) {}
void nvg_LineTo(float x, float y) {}
void nvg_BezierTo(float c1x, float c1y, float c2x, float c2y, float x, float y) {}
void nvg_QuadTo(float cx, float cy, float x, float y) {}
void nvg_ArcTo(float x1, float y1, float x2, float y2, float radius) {}
void nvg_ClosePath() {}
void nvg_PathWinding(int dir) {}
void nvg_Arc(float cx, float cy, float r, float a0, float a1, int dir) {}
void nvg_Rect(float x, float y, float w, float h) {}
void nvg_RoundedRect(float x, float y, float w, float h, float r) {}
void nvg_RoundedRectVarying(float x, float y, float w, float h,
	float radTopLeft, float radTopRight, float radBottomRight, float radBottomLeft) {}
void nvg_Ellipse(float cx, float cy, float rx, float ry) {}
void nvg_Circle(float cx, float cy, float r) {}
void nvg_Fill() {}
void nvg_Stroke() {}
void nvg_StrokeNoScale() {}

// Text
int nvg_CreateFont(string name, string filename) {}
int nvg_CreateFontMem(string name, xptr data, int ndata, int freeData) {}
int nvg_FindFont(string name) {}
int nvg_AddFallbackFontId(int baseFont, int fallbackFont) {}
int nvg_AddFallbackFont(string baseFont, string fallbackFont) {}
void nvg_FontSize(float size) {}
void nvg_FontBlur(float blur) {}
void nvg_TextLetterSpacing(float spacing) {}
void nvg_TextLineHeight(float lineHeight) {}
void nvg_TextAlign(int align) {}
void nvg_FontFaceId(int font) {}
void nvg_FontFace(string font) {}
void nvg_Text(float x, float y, string str, string end) {}
void nvg_TextBox(float x, float y, float breakRowWidth, string str, string end) {}
float nvg_TextBounds(float x, float y, string str, string end, xptr bounds) {}
void nvg_TextBoxBounds(float x, float y, float breakRowWidth, string str, string end, vec4 bounds) {}
void nvg_TextMetrics(ref float ascender, ref float descender, ref float lineh) {}

// SVG support
xptr nsvg_ParseFromFile(string filename, string units, float dpi) {}
xptr nsvg_ParseMem(string data, int ndata, string units, float dpi) {}
void nsvg_ImageSize(xptr image, ref float width, ref float height) {}
int nsvg_ImageShapeCount(xptr image, string shapeIdPrefix) {}
void nsvg_Draw(xptr image, string shapeIdPrefix,
  int strokeWidthScaling, float strokeWidthFactor, float buildUpFromFactor, float buildUpToFactor, xptr color) {}
void nsvg_Rasterize(xptr image, float tx, float ty, float scale, xptr dst, int w, int h) {}
void nsvg_Delete(xptr image) {}]]>
      </Source>
    </ZExternalLibrary>
    <ZExternalLibrary ModuleName="ZGameEditor Visualizer">
      <Source>
<![CDATA[// ZGameEditor Visualizer built-in functions

void ParamsWriteValueForLayer(xptr Handle, int Layer,int Param, float NewValue) { }
void ParamsUpdateComboItems(xptr Handle, int Layer,int Param, string[] NewItems) { }
int ReadPrivateData(xptr Handle, xptr Data, int Size) { }
void WritePrivateData(xptr Handle, xptr Data, int Size) { }
void ZgeVizGetFileNames(string path, string pattern, string[] list) { }
void ZgeVizFontGetContent(string FileName,ref xptr ContentMem, ref int ContentSize) { }]]>
      </Source>
    </ZExternalLibrary>
    <ZLibrary Comment="HSV conversion by Kjell">
      <Source>
<![CDATA[float angle(float X)
{
  if(X >= 0 && X < 360)return X;
  if(X > 360)return X-floor(X/360)* 360;
  if(X <   0)return X+floor(X/360)*-360;
}

void hsv(float H, float S, float V, ref vec4 c)
{
  float R,G,B,I,F,P,Q,T;

  H = angle(H);
  S = clamp(S,0,100);
  V = clamp(V,0,100);

  H /= 60;
  S /= 100;
  V /= 100;

  if(S == 0)
  {
    c.R = V;
    c.G = V;
    c.B = V;
    return;
  }

  I = floor(H);
  F = H-I;

  P = V*(1-S);
  Q = V*(1-S*F);
  T = V*(1-S*(1-F));

  if(I == 0){R = V; G = T; B = P;}
  if(I == 1){R = Q; G = V; B = P;}
  if(I == 2){R = P; G = V; B = T;}
  if(I == 3){R = P; G = Q; B = V;}
  if(I == 4){R = T; G = P; B = V;}
  if(I == 5){R = V; G = P; B = Q;}

  c.R = R;
  c.G = G;
  c.B = B;
}]]>
      </Source>
    </ZLibrary>
    <ZLibrary Comment="Effect interface">
      <Source>
<![CDATA[const string AuthorInfo = "Impostorem\nhttp://www.impostorem.com\nBased on Rado1's ZgeNano library and HUD Text";

// PARAMETERS

const string ParamHelpConst =
"Alpha\n" +
"Hue\n" +
"Saturation\n" +
"Lightness\n" +
"Position X\n" +
"Position Y\n" +
"Rotation\n" +
"Text line\n" +
"Font @list1000:\n" +
"Font size\n" +
"Letter spacing\n" +
"Attack/Release @checkbox\n" +
"FX per @list: Line, Word\n" +
"Attack FX @list1000: None,Fade,Blur,Expander, VertSlide,HorzSlide,FontScale\n" +
"Attack Length\n" +
"Hold FX @list1000: None, Rise, Wander\n" +
"Hold Length\n" +
"Hold Strength\n" +
"Release FX @list1000: None,Fade,Blur,Expander,VertSlide,HorzSlide,FontScale\n" +
"Release Length\n" +
"Beat FX @list1000: None,Fade,Blur,Expander,FontScale\n" +
"Beat Strength\n" +
"Beat Wave @list: Saw,1-Saw, Sin, 1-Sin\n" +
"MIDI Chan @list: None,Any,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16\n" +
"First Note @list: C0,C1,C2,C3,C4,C5,C6,C7,C8,C9\n"
;


const int
  P_ALPHA = 0,
  P_HUE = 1,
  P_SATURATION = 2,
  P_LIGHTNESS = 3,
  P_POSITION_X = 4,
  P_POSITION_Y = 5,
  P_ROTATION = 6,
  P_TEXT_LINE = 7,
  P_FONT = 8,
  P_FONT_SIZE = 9,
  P_LETTER_SPACING = 10,
  P_ENABLE_FX = 11,
  P_EFFECT_PER = 12,
  P_ATTACK_FX = 13,
  P_ATTACK_LEN = 14,
  P_HOLD_FX = 15,
  P_HOLD_LEN = 16,
  P_HOLD_STRENGTH = 17,
  P_RELEASE_FX = 18,
  P_RELEASE_LEN = 19,
  P_BEAT_FX = 20,
  P_STRENGTH = 21,
  P_WAVE = 22,
  P_MIDI_CHANNEL = 23,
  P_MIDI_FIRST = 24,
  NUM_OF_PARAMS = 25;

const int
  NUM_ATTACK_FX_TYPES = 7,
  NUM_HOLD_FX_TYPES = 3,
  NUM_RELEASE_FX_TYPES = 7,
  NUM_BEAT_FX_TYPES = 5,
  NUM_WAVE_TYPES = 4,
  NUM_MIDI_CHANNELS=18,
  NUM_FIRST_NOTES=10;

// Effects maps by type
int[NUM_ATTACK_FX_TYPES]  AttackFXTypes;
int[NUM_HOLD_FX_TYPES]    HoldFXTypes;
int[NUM_RELEASE_FX_TYPES] ReleaseFXTypes;
int[NUM_BEAT_FX_TYPES]    BeatFXTypes;

// Plugin / FLStudio
xptr FLPluginHandle;
int LayerNr;
string FLPluginPath;
string[0] UserTextArray;
int FLShowEditor;
float FLGraphicsScaleFactor;

float[NUM_OF_PARAMS] ParamOld;
int[NUM_OF_PARAMS] ParamChanged;

vec4 Color;]]>
      </Source>
    </ZLibrary>
    <ZLibrary Comment="Globals">
      <Source>
<![CDATA[// CONSTANTS

// determines processing mode flag for OnHostMessage
private const int FPD_ProcessMode = 1;

// boolean
const int FALSE = 0;
const int TRUE = 1;
const float PI2 = PI * 2.0;

// VARIABLES
xptr NvgContext;
string FontDir;
float ViewportWidth, ViewportHeight, AspectRatio;
float
  PosX,
  PosY,
  Rotation,
  PlaceValueMultiplier,
  FontSize,
  RowWidth,
  LineHeight,
  LetterSpacing;

int
  CurrentFont,
  AlignHoriz,
  AlignVert;

// FX sequence
const int
  FX_BYPASS = 0,   // Text is drawn, but no effects.
  FX_ATTACK = 1,   // First portion
  FX_HOLD = 2,     // Middle portion
  FX_RELEASE = 3,  // End portion
  FX_BEAT = 4,     // During all sequences but none
  FX_NONE = 5;     // Sequence completed, nothing drawn.

// FX type
const int
  FX_TYPE_NONE = 0,
  FX_TYPE_FADE = 1,
  FX_TYPE_BLUR = 2,
  FX_TYPE_EXPANDER = 3,
  FX_TYPE_VERTICAL = 4,
  FX_TYPE_HORZSLIDE = 5,
  FX_TYPE_FONTSCALE = 6,
  FX_TYPE_RISE = 7,
  FX_TYPE_WANDER = 8;

const int WAVE_SAW = 0,
          WAVE_SAW_1 = 1,
          WAVE_SIN = 2,
          WAVE_SIN_1 = 3;

// Current and previous text line
// For reading the lyrics from the ZGEV data
string Text;
int CurTextLine;
int TextChanged;


int   FXType;     // FX_TYPE_NONE, FX_TYPE_FADE, etc.
int   FXSequence; // FX_BYPASS/FX_ATTACK/FX_HOLD, etc.
float FXPosition; // Where are we in current sequence?

// TODO:
// These all track which part of the fx we're in...
// We have two sources of changes - the TextLine plus timing,
// and the MIDI notes if triggered by them.  We'll want to
// simplify and consolidate this as much as possible....

float FXSequenceStart; // When did the transition occur?

// MIDI Tracking if it triggered change
int ActiveMIDINote;
int ActiveMIDIChannel;
int MIDITriggered;




// FX-related variable. Each effect may use one or more of
// these to change the text display
float FXStrength;
float FadeAlpha;
float VerticalSlide; // Fade in/out vertically
float HorizontalSlide;
float FontScale; // multiplier for FontSize for effects
int   FontId;
float Blur;

// These two are kinda special, in that only HOLD effects
// modify them and they should be left unchanged going from
// hold into release.
float VertOffset;
float HorzOffset;

// Similar here, but they need to be cumulative
float FXWanderX;
float FXWanderY;


// font TTF files
string[0] FontFiles;

// FUNCTIONS
inline float distSigned(float a, float b) {
  return sqrt(a*a + b*b) * (a + b > 0 ? 1 : -1);
}

inline int max(int a, int b) {
  return a > b ? a : b;
}

// callback on hanged OpenGL context
void OnGLContextChange() {
  // reset NanoVG
  @CallComponent(Component: InitNanoVG);
}

// Callback on writing private data to effect level; called on project saving.
void OnWritePrivateData() {
  byte[256] name;
  string s = FontFiles[CurrentFont];

  // copy file name to array
  name[length(s)] = 0;
  for(int i = length(s) - 1; i >= 0; --i)
    name[i] = ord(substr(s, i, 1));

  // write array
  WritePrivateData(FLPluginHandle, name, 256);
}

// Callback on reading private data to effect level; called on project loading.
void OnReadPrivateData() {
  byte[256] name;
  string s;

  // read array
  int read = ReadPrivateData(FLPluginHandle, name, 256);
  if (read == 0) return;

  // copy to string
  s = "";
  int hasExtension=0;
  for(int i = 0; name[i] != 0; ++i) {
    string onechar=chr(name[i]);
    if(onechar==".")
      hasExtension=1;
    s = s + onechar;
  }
  if(!hasExtension)
    //If project was saved before file extensions were added then default to ".ttf"
    s=s+".ttf";

  for (int i = FontFiles.SizeDim1 - 1; i >= 0; --i)
    if (FontFiles[i] == s) {
      ParamsWriteValueForLayer(FLPluginHandle, LayerNr, P_FONT, i / 1000.0);
      break;
    }
}

// Callback to handle external messages
void OnHostMessage(int id, int index, int value)
{
  if(id == FPD_ProcessMode)
  {
    if (value & 16)
    {
      // video rendering
    } else
    {
      // return from rendering
    }
  }
}

// reading fonts and setting the combo box
void InitFonts()
{
  if (MACOS)
    FontDir = FLPluginPath + "Effects/HUD/fonts/";
  else
    FontDir = FLPluginPath + "Effects\\HUD\\fonts\\";

  ZgeVizGetFileNames(FontDir, "*.ttf;*.zfo", FontFiles);

  // prepare font names without file extension
  string[0] names;
  names.SizeDim1 = FontFiles.SizeDim1;
  for (int i = names.SizeDim1 - 1; i >= 0; --i)
    names[i] = subStr(FontFiles[i], 0, length(FontFiles[i])-4);

  ParamsUpdateComboItems(FLPluginHandle, LayerNr, P_FONT, names);
}

// recompute all parameters
void ResetOldParameters()
{
  for(int i = 0; i < NUM_OF_PARAMS; ++i)
    ParamOld[i] = -1;
}]]>
      </Source>
    </ZLibrary>
    <ZLibrary Name="Effects">
      <Source>
<![CDATA[// Returns 0-1, where 0 is on the beat
float beatPos()
{
  int posBeats = SongPositionInBeats;
  return SongPositionInBeats - posBeats;
}

// Returns the beat position given the selected
// wave form.
float beatMul()
{
  int   wave = Parameters[P_WAVE] * NUM_WAVE_TYPES;
  float waveVal = 1.0;

  switch  (wave)
  {
    case WAVE_SAW:
       waveVal = beatPos();
       break;
    case WAVE_SAW_1:
       waveVal = 1.0 - beatPos();
       break;
    case WAVE_SIN:
       waveVal = sin(beatPos()*PI);
       break;
    case WAVE_SIN_1:
       waveVal = 1.0 - sin(beatPos()*PI);
       break;
  }
  return abs(waveVal * FXStrength);
}

// Returns alpha multiplier given sequence and position
float FadeEffect(int sequence, float position)
{
  float alphaMul = 1.0;
  // Fade effect
  switch (sequence)
  {
    case FX_ATTACK:
      alphaMul = position;
      break;
    case FX_HOLD:
      break;
    case FX_BEAT:
      alphaMul = 1.0 - position;
      break;
    case FX_RELEASE:
      alphaMul = 1.0 - position;
      break;
    case FX_BYPASS:
      break;
    case FX_NONE:
      break;
  }
  return alphaMul;
}

float BlurEffect(int sequence, float position)
{
  float blurMul = 0;
  switch (sequence)
  {
    case FX_ATTACK:
      blurMul = 1.0 - position;
      break;
    case FX_HOLD:
      break;
    case FX_BEAT:
      blurMul = position;
      break;
    case FX_RELEASE:
      blurMul = position;
      break;
    case FX_BYPASS:
      break;
    case FX_NONE:
      break;
  }
  return blurMul;
}

float ExpanderEffect(int sequence, float position)
{
  float expander = LetterSpacing;
  switch (sequence)
  {
    case FX_ATTACK:
      expander = LetterSpacing + FontSize*(1.0 - position);
      break;
    case FX_HOLD:
      break;
    case FX_BEAT:
      expander = LetterSpacing + FontSize*(position);
      break;
    case FX_RELEASE:
      expander = LetterSpacing + FontSize*(position);
      break;
    case FX_BYPASS:
      break;
    case FX_NONE:
      break;
  }
  return expander;
}

float VerticalEffect(int sequence, float position)
{
  float slide = 0;
  switch (sequence)
  {
    case FX_ATTACK:
      slide = 1 - position;
      break;
    case FX_RELEASE:
      slide = position;
      break;

    case FX_HOLD:
    case FX_BEAT:
    case FX_BYPASS:
    case FX_NONE:
      break;
  }
  return slide;
}

float HorzSlideEffect(int sequence, float position)
{
  float slide = 0;
  switch (sequence)
  {
    case FX_ATTACK:
      slide = 1.0 - position;
      break;
    case FX_RELEASE:
      slide = position;
      break;

    case FX_HOLD:
    case FX_BEAT:
    case FX_BYPASS:
    case FX_NONE:
      break;
  }
  return slide;
}

float FontScaleEffect(int sequence, float position)
{
  float scale = 1.0;
  switch (sequence)
  {
    case FX_ATTACK:
      scale = position;
      break;
    case FX_RELEASE:
      scale = 1.0 - position;
      break;
    case FX_BEAT:
      scale = 1.0 + position;
      break;
    case FX_HOLD:
    case FX_BYPASS:
    case FX_NONE:
      break;
  }
  return scale;
}

float RiseEffect(int sequence, float position)
{
  float rise = 1.0;
  switch (sequence)
  {
    case FX_ATTACK:
      rise = -position;
      break;
    case FX_RELEASE:
      rise = -position;
      break;
    case FX_BEAT:
      rise = -position;
      break;
    case FX_HOLD:
      rise = -position;
    case FX_BYPASS:
    case FX_NONE:
      break;
  }
  return rise;
}

void WanderEffect(int sequence, float position)
{
  if (sequence == FX_HOLD)
  {
    FXWanderX += random(0,Parameters[P_HOLD_STRENGTH]*2);
    FXWanderY += random(0,Parameters[P_HOLD_STRENGTH]*2);
  }
}]]>
      </Source>
    </ZLibrary>
    <ZLibrary Name="MIDILine">
      <Source>
<![CDATA[void OnNoteOn(int channel, int note, int velo)
{
   // First note is the one at 0.  We ignore anything below.
   int firstNote = PARAMETERS[P_MIDI_FIRST] * NUM_FIRST_NOTES;
   firstNote *= 12;

   if (note < firstNote)
   {
     return;
   }

   int newTextLine = note - firstNote;

   // Set the textLine parameter.
   if (newTextLine < UserTextArray.SizeDim1)
   {
       // Store current to track when it's released.
       ActiveMIDINote = note;
       ActiveMIDIChannel = channel;
       MIDITriggered = 1;

       // Set the text line parameter
       float newLineVal = newTextLine;
       float numLines = UserTextArray.SizeDim1-1;
       newLineVal /= numLines;
       ParamsWriteValueForLayer(FLPluginHandle, LayerNr,P_TEXT_LINE,newLineVal);

       // Mirror the actions taken on param change.
       CurTextLine     = newTextLine;
       TextChanged     = 1;
       FXSequence      = FX_Attack;
       FXSequenceStart = SongPositionInBeats;
       HorzOffset = 0;
       VertOffset = 0;
       FXWanderX = 0;
       FXWanderY = 0;
  }
}

void OnNoteOff(int channel, int note)
{
  if ((note == ActiveMIDINote) && (channel == ActiveMIDIChannel))
  {
    // Begin release sequence.
    FXSequence      = FX_Release;
    FXSequenceStart = SongPositionInBeats;

    ActiveMIDINote    = -1;
    ActiveMIDIChannel = -1;
    MIDITriggered = 0;
  }
}



void OnMidiMessage(int status, int data1, int data2)
{
  int midOpt = Parameters[P_MIDI_CHANNEL]*NUM_MIDI_CHANNELS;
  trace("midOpt: " + intToStr(midOpt));
  // Skip if MIDI isn't enabled
  if (midOpt == 0)
  {
    return;
  }

  int channel = status & 0x0f;
  int opcode = status & 0xf0;

  // Skip if channel doesn't match (first is none, second is any, hence -2)
  if (midOpt > 1)
  {
    int ourChannel =  midOpt - 2;
    if (channel != ourChannel)
    {
      return;
    }
  }

  switch (opcode)
  {
    case 0x80:
      // Note off
      onNoteOff(channel, data1);
      break;
    case 0x90:
      // Note on
      onNoteOn(channel, data1, data2);
      break;
    case 0xa0: // polyphonic aftertouch
      //trace("PAT ch " + intToStr(channel));
      break;
    case 0xb0: // control change
      //trace("CC ch " + intToStr(channel));
      break;
    case 0xc0: // program change
      //trace("PC ch " + intToStr(channel));
      break;
    case 0xd0: // aftertouch
      //trace("AT ch " + intToStr(channel));
      break;
    case 0xe0: // Pitch wheel
      //trace("PW ch " + intToStr(channel));
      break;
    case 0xf0: // system messages
      //trace("SYS");
      break;
    default: // ?
      trace("UNKNOWN MIDI: " + IntToStr(status) + "," + IntToStr(data1) + "," + IntToStr(data2));
      break;
  }
}]]>
      </Source>
    </ZLibrary>
    <ZExpression Comment="Init">
      <Expression>
<![CDATA[// Not sure here - we may want to seed to a slider or similar.
// For some effects, I suspect we'll want "random" but
// fully repeatable if everything is otherwise left alone.
// But that seeding may need to come per trigger or similar to
// really work.
setRandomSeed(getSystemTime());

InitFonts();
ResetOldParameters();

// Initialize text changes
CurTextLine    = 0;
Text           = "";
TextChanged    = 0;

// MIDI tracking
ActiveMIDINote    = -1;
ActiveMIDIChannel = -1;
MIDITriggered     = 0;

// Hmmm... best way to init these? They must match EffectsInterface
// lists and map the menu item to the FX type defined in Globals.
AttackFXTypes[0]  = FX_TYPE_NONE;
AttackFXTypes[1]  = FX_TYPE_FADE;
AttackFXTypes[2]  = FX_TYPE_BLUR;
AttackFXTypes[3]  = FX_TYPE_EXPANDER;
AttackFXTypes[4]  = FX_TYPE_VERTICAL;
AttackFXTypes[5]  = FX_TYPE_HORZSLIDE;
AttackFXTypes[6]  = FX_TYPE_FONTSCALE;

HoldFXTypes[0]  = FX_TYPE_NONE;
HoldFXTypes[1]  = FX_TYPE_RISE;
HoldFXTypes[2]  = FX_TYPE_WANDER;

ReleaseFXTypes[0] = FX_TYPE_NONE;
ReleaseFXTypes[1] = FX_TYPE_FADE;
ReleaseFXTypes[2] = FX_TYPE_BLUR;
ReleaseFXTypes[3] = FX_TYPE_EXPANDER;
ReleaseFXTypes[4] = FX_TYPE_VERTICAL;
ReleaseFXTypes[5] = FX_TYPE_HORZSLIDE;
ReleaseFXTypes[6] = FX_TYPE_FONTSCALE;

BeatFXTypes[0] = FX_TYPE_NONE;
BeatFXTypes[1] = FX_TYPE_FADE;
BeatFXTypes[2] = FX_TYPE_BLUR;
BeatFXTypes[3] = FX_TYPE_EXPANDER;
BeatFXTypes[4] = FX_TYPE_FONTSCALE;]]>
      </Expression>
    </ZExpression>
    <ZExpression Name="InitNanoVG">
      <Expression>
<![CDATA[// init NanoVG
NvgContext = nvg_Init(NVG_STENCIL_STROKES);
if (NvgContext == null) {
  trace("Error to init NanoVG.");
  quit();
}
// enforce recomputing viewport size and font reloading
ViewportWidth = -1;]]>
      </Expression>
    </ZExpression>
    <SetAppState State="MainAppState"/>
  </OnLoaded>
  <States>
    <AppState Name="MainAppState" CollisionsEnabled="0">
      <OnUpdate>
        <Condition Expression="return App.ViewportWidth != 0;">
          <OnTrue>
            <ZExpression Comment="Compute shape parameters">
              <Expression>
<![CDATA[// Rado1's update code from HUD Text, with
// various parts removed.

xptr cont;
int s = FALSE, f = FALSE; // flags of changing size, text or font

// reload font if NVG context has changed
if (ViewportWidth == -1) {
  f = TRUE;
}

// resize if viewport has changed
if (nvg_SetViewport(NvgContext))
{
  ViewportWidth = App.ViewportWidth;
  ViewportHeight = App.ViewportHeight;
  AspectRatio = ViewportWidth / ViewportHeight;
  s = TRUE;
}


// update parameter change
for(int i = 0; i < NUM_OF_PARAMS; ++i) {
  ParamChanged[i] = Parameters[i] != ParamOld[i];
  if (ParamChanged[i])
    ParamOld[i] = Parameters[i];
}

// check changed parameters

// update color
if (ParamChanged[P_HUE] || ParamChanged[P_SATURATION] || ParamChanged[P_LIGHTNESS] ||
  ParamChanged[P_ALPHA])

  hsv(Parameters[P_HUE]*360,Parameters[P_SATURATION]*100,(1-Parameters[P_LIGHTNESS])*100, Color);
  Color.A = 1 - Parameters[P_ALPHA];

// position X
if (ParamChanged[P_POSITION_X] || s)
  PosX = Parameters[P_POSITION_X] * ViewportWidth;

// position Y
if (ParamChanged[P_POSITION_Y] || s)
  PosY = Parameters[P_POSITION_Y] * ViewportHeight;

// rotation
if (ParamChanged[P_ROTATION])
  Rotation = (Parameters[P_ROTATION] - 0.5) * PI2;

// font
if (ParamChanged[P_FONT] || f) {

  CurrentFont = round(Parameters[P_FONT] * 1000);
  string fn = FontFiles[CurrentFont];

  // load font
  FontId = nvg_FindFont(fn);
  if (FontId < 0) {
    xptr contentMem;
    int contentSize;
    ZgeVizFontGetContent(FontDir + fn,contentMem, contentSize);
    FontId = nvg_CreateFontMem(fn, contentMem, contentSize, 0);
  }
}

// font size
if (ParamChanged[P_FONT_SIZE] || s) {
  FontSize = Parameters[P_FONT_SIZE] * Parameters[P_FONT_SIZE] * ViewportHeight;
  s = TRUE;
}

// letter spacing
if (ParamChanged[P_LETTER_SPACING] || s)
  LetterSpacing = (Parameters[P_LETTER_SPACING] - 0.5) * FontSize * 2.0;

// Effects may play with these.
Blur = 0;
AlignHoriz = NVG_ALIGN_CENTER;
AlignVert  = NVG_ALIGN_MIDDLE;

float ascender, descender;
nvg_TextMetrics(ascender,descender,LineHeight);]]>
              </Expression>
            </ZExpression>
            <ZExpression Name="UpdateEffectsForText">
              <Expression>
<![CDATA[// This file handles text/effects transitions and
// setting up the effect parameters for drawing later
// during OnRender().
FXStrength = Parameters[P_STRENGTH];

// Update text and timer
if (!MIDITriggered)
{
  int newTextLine = round(Parameters[P_TEXT_LINE] * (UserTextArray.SizeDim1-1));
  if (CurTextLine != newTextLine)
  {
    CurTextLine     = newTextLine;
    TextChanged     = 1;

    FXSequence      = FX_Attack;
    FXSequenceStart = SongPositionInBeats;
    HorzOffset = 0;
    VertOffset = 0;
    FXWanderX = 0;
    FXWanderY = 0;
  }


  // If we changed fx enable, restart it.
  if (ParamChanged[P_ENABLE_FX])
  {
    FXSequence      = FX_Attack;
    FXSequenceStart = SongPositionInBeats;
    HorzOffset = 0;
    VertOffset = 0;
    FXWanderX = 0;
    FXWanderY = 0;
  }
}

// Ew... This can be ugly with loops / restarts.
// I'm seeing the song position coming in as 10 for the
// very first beat in the song sometimes.
if (FXSequenceStart > SongPositionInBeats)
{
  FXSequenceStart = SongPositionInBeats;
}

// Copy out text
Text = UserTextArray.SizeDim1 > 0
  ? UserTextArray[CurTextLine]
  : "";

// We pad the length to even so there's not a center character.
// It makes effects like Expander look way better.
if (Length(Text) & 1)
{
  Text += " ";
}

// Scale attack/hold/release values to usable numbers of beats.
float FXScale    = 16;
float AttackLen  = Parameters[P_ATTACK_LEN] * 4;
float HoldLen    = Parameters[P_HOLD_LEN]   * FXScale;
float ReleaseLen = Parameters[P_RELEASE_LEN]* 4;


FXPosition = 0.0;

// Figure out which state A/H/R we're in and our position in it.
// If text was triggered by TextLine change only, then we use
// time scales.  If triggered by MIDI, then the Hold and Release
// are controlled by the MIDI note itself.

// curSeqLen is how long we've been in the current sequence state.
float curSeqLen = SongPositionInBeats - FXSequenceStart;
FXType = FX_TYPE_NONE;

// If we're in attack, see if we need to transition.
// If not, set FX type and position.
if (FXSequence == FX_Attack)
{
  if ((curSeqLen > AttackLen) || (AttackLen == 0))
  {
    FXSequence = FX_Hold;
    FXSequenceStart = SongPositionInBeats;
    FXPosition = 0;
    curSeqLen = 0;
  }
  else
  {
    int index = Parameters[P_ATTACK_FX] * 1000;
    FXType = AttackFXTypes[index];
    FXPosition = curSeqLen / AttackLen;
  }
}

// If we're in hold, see if we need to transition.
// If not, set FX type and position.
if (FXSequence == FX_Hold)
{
  // If triggered by MIDI, continue hold until released.
  if ( ((curSeqLen > HoldLen) && (MIDITriggered == 0))
       || (HoldLen == 0))
  {
    FXSequence = FX_Release;
    FXSequenceStart = SongPositionInBeats;
    FXPosition = 0;
    curSeqLen = 0;
  }
  else
  {
    int index = Parameters[P_HOLD_FX] * 1000;
    FXType = HoldFXTypes[index];
    FXPosition = curSeqLen / HoldLen;
  }
}

// If we're in release, see if we need to transition.
// If not, set FX type and position.
if (FXSequence == FX_Release)
{
  if ((curSeqLen > ReleaseLen) || (ReleaseLen == 0))
  {
    FXSequence = FX_None;
    FXSequenceStart = SongPositionInBeats;
    FXPosition = 0;
    curSeqLen = 0;
  }
  else
  {
    int index = Parameters[P_RELEASE_FX] * 1000;
    FXType = ReleaseFXTypes[index];
    FXPosition = curSeqLen / ReleaseLen;
  }
}

// Setup the effect parameters here - start with defaults
// Rendering is another step
FadeAlpha = 1.0;
Blur = 0;
LetterSpacing = (Parameters[P_LETTER_SPACING] - 0.5) * FontSize * 2.0;
VerticalSlide = 0;
HorizontalSlide = 0;
FontScale = 1.0;

// Wondering if this should become velocity for MIDI notes?
float HoldStrength = Parameters[P_HOLD_STRENGTH];

// Some HOLD FX will move the text to a new location -
// in RELEASE, we just want to keep where we ended up.
if (FXSequence != FX_RELEASE)
{
  VertOffset = 0.0;
  HorzOffset = 0.0;
}


switch (FXType)
{
  case FX_TYPE_NONE:
    break;
  case FX_TYPE_FADE:
    FadeAlpha = FadeEffect(FXSequence, FXPosition);
    break;
  case FX_TYPE_BLUR:
    Blur = BlurEffect(FXSequence, FXPosition)*20;
    break;
  case FX_TYPE_EXPANDER:
    LetterSpacing = ExpanderEffect(FXSequence, FXPosition);
    break;
  case FX_TYPE_VERTICAL:
    VerticalSlide = VerticalEffect(FXSequence, FXPosition);
    break;
  case FX_TYPE_HORZSLIDE:
    HorizontalSlide = HorzSlideEffect(FXSequence, FXPosition);
    break;
  case FX_TYPE_FONTSCALE:
    FontScale = FontScaleEffect(FXSequence,FXPosition);
    break;
  case FX_TYPE_RISE:
    VertOffset = RiseEffect(FXSequence,FXPosition)*HoldStrength*50;
    break;
  case FX_TYPE_WANDER:
    WanderEffect(FXSequence,FXPosition);
    break;
 }

// If fade transitions...
if ((FXSequence == FX_ATTACK) || (FXSequence == FX_RELEASE))
{
    if ((FX_TYPE_FADE != FXType) && (FX_TYPE_NONE != FXTYPE))
    {
      FadeAlpha = FadeEffect(FXSequence, FXPosition);
    }
}

// Add in beat FX on top of attack/hold/release fx.
int beatType = BeatFXTypes[Parameters[P_BEAT_FX]*1000];
float fontMul = 1.0;
switch (beatType)
{
  case FX_TYPE_NONE:
    break;
  case FX_TYPE_FADE:
    FadeAlpha *= FadeEffect(FX_BEAT, beatMul());
    break;
  case FX_TYPE_BLUR:
    Blur += BlurEffect(FX_BEAT, beatMul())*20;
    break;
  case FX_TYPE_EXPANDER:
    LetterSpacing += ExpanderEffect(FX_BEAT, beatMul());
    break;
  case FX_TYPE_FONTSCALE:
    fontMul = FontScaleEffect(FX_BEAT,beatMul());
    FontScale *= fontMul;
    break;
}]]>
              </Expression>
            </ZExpression>
          </OnTrue>
        </Condition>
      </OnUpdate>
      <OnRender>
        <ZExpression Name="DrawTheText">
          <Expression>
<![CDATA[float[8] bounds;

nvg_SetContext(NvgContext);

//Text

if (FXSequence != FX_NONE)
{
  nvg_BeginFrame();

  nvg_FontFaceId(FontId);
  nvg_TextAlign(AlignHoriz | AlignVert);
  nvg_FontSize(FontSize*FontScale);
  nvg_FillColor(Color.R, Color.G, Color.B, Color.A * FadeAlpha);
  nvg_FontBlur(Blur);

  nvg_Translate(PosX+FXWanderX+HorzOffset, PosY+VertOffset+FXWanderY);
  nvg_Rotate(Rotation);
  nvg_TextLetterSpacing(LetterSpacing);

  nvg_TextBounds(0,0, Text,null, bounds);
  nvg_Scissor(bounds[0],bounds[1],bounds[2] - bounds[0],bounds[3] - bounds[1]);

  nvg_Text(bounds[2]*HorizontalSlide*2, bounds[3]*VerticalSlide, Text, null);

  nvg_ResetScissor();
  nvg_EndFrame();
}]]>
          </Expression>
        </ZExpression>
      </OnRender>
    </AppState>
  </States>
  <OnClose>
    <ZExpression Name="FinishNanoVG">
      <Expression>
<![CDATA[nvg_SetContext(NvgContext);
nvg_Finish(NvgContext);]]>
      </Expression>
    </ZExpression>
  </OnClose>
  <Content>
    <Array Name="Parameters" SizeDim1="28" Persistent="255">
      <Values>
<![CDATA[789C636000037B0604B047C260306BE64C3B08BF012C962FD46C0DA4EC80B4952D5738586ED9EC2350316620DD001263783C21D9F6EC9933764866330000D4DF108C]]>
      </Values>
    </Array>
    <Array Name="SpecBandArray"/>
    <Material Name="Material1">
      <Textures>
        <MaterialTexture Name="FLEditorMaterialTexture"/>
      </Textures>
    </Material>
    <Array Name="AudioArray"/>
    <Variable Name="SongPositionInBeats"/>
    <Variable Name="bounds" Type="8"/>
  </Content>
</ZApplication>
