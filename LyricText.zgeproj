<?xml version="1.0" encoding="iso-8859-1" ?>
<ZApplication Name="App" Caption="HUD Line" ClearColor="0 0 0 1" AmbientLightColor="0.7529 0.7529 0.7529 1" ScreenMode="0" CameraPosition="0 0 30" LightPosition="200 200 200" ViewportRatio="2" FOV="70" ClipFar="1000" MouseVisible="255" UseStencilBuffer="255" FileVersion="2">
  <Comment>
<![CDATA[TextAnimation app

This is heavily based off Rado1's HUD Text and uses his ZgeNanoVG
 library.  It is intended to greatly simplify scripting text animations for 
lyric-style videos.

You'll need to automate the "Text line" control to pick lyrics from the
"Add content->Text" page in ZGE Visualizer.

When the text changes, it starts an Attack, which lasts for the
specified length (the slider is a multiplier on beats).

After the attack effect, it goes to hold, then to release.

On top of the A/H/R effects, the Beat FX will be applied if one
is selected.]]>
  </Comment>
  <OnLoaded>
    <ZExternalLibrary Comment="Vector graphics library" ModuleName="ZgeNano" CallingConvention="1">
      <Source>
<![CDATA[/*
  ZgeNano Library; vector graphics rendering library
  build on NanoVG: https://github.com/memononen/nanovg
  and NanoSVG: https://github.com/memononen/nanosvg

  Version: 1.4 (2018-09-10)

  Download Windows DLL and Android shared library from
  https://github.com/Rado-1/ZgeNano/releases

  Project home
  https://github.com/Rado-1/ZgeNano

  Copyright (c) 2016-2018 Radovan Cervenka
*/

// init flags
const int
  NVG_ANTIALIAS = 1<<0,
	NVG_STENCIL_STROKES = 1<<1,
	NVG_DEBUG = 1<<2;

// winding (direction of arcs)
const int
  NVG_CCW = 1, // counter-clockwise
  NVG_CW = 2; // clockwise

// solidity
const int
  NVG_SOLID = 1,
	NVG_HOLE = 2;

// line caps
const int
	NVG_BUTT = 0,
	NVG_ROUND = 1,
	NVG_SQUARE = 2,
	NVG_BEVEL = 3,
	NVG_MITER = 4;

// align
const int
	// Horizontal align
	NVG_ALIGN_LEFT 		= 1<<0,	// Default, align text horizontally to left.
	NVG_ALIGN_CENTER 	= 1<<1,	// Align text horizontally to center.
	NVG_ALIGN_RIGHT 	= 1<<2,	// Align text horizontally to right.
	// Vertical align
	NVG_ALIGN_TOP 		= 1<<3,	// Align text vertically to top.
	NVG_ALIGN_MIDDLE	= 1<<4,	// Align text vertically to middle.
	NVG_ALIGN_BOTTOM	= 1<<5,	// Align text vertically to bottom.
	NVG_ALIGN_BASELINE	= 1<<6; // Default, align text vertically to baseline.

// blend factor
const int
	NVG_ZERO = 1<<0,
	NVG_ONE = 1<<1,
	NVG_SRC_COLOR = 1<<2,
	NVG_ONE_MINUS_SRC_COLOR = 1<<3,
	NVG_DST_COLOR = 1<<4,
	NVG_ONE_MINUS_DST_COLOR = 1<<5,
	NVG_SRC_ALPHA = 1<<6,
	NVG_ONE_MINUS_SRC_ALPHA = 1<<7,
	NVG_DST_ALPHA = 1<<8,
	NVG_ONE_MINUS_DST_ALPHA = 1<<9,
	NVG_SRC_ALPHA_SATURATE = 1<<10;

// composite operation
const int
	NVG_SOURCE_OVER = 0,
	NVG_SOURCE_IN = 1,
	NVG_SOURCE_OUT = 2,
	NVG_ATOP = 3,
	NVG_DESTINATION_OVER = 4,
	NVG_DESTINATION_IN = 5,
	NVG_DESTINATION_OUT = 6,
	NVG_DESTINATION_ATOP = 7,
	NVG_LIGHTER = 8,
	NVG_COPY = 9,
	NVG_XOR = 10;

// image flags
const int
  NVG_IMAGE_GENERATE_MIPMAPS	= 1<<0,     // Generate mipmaps during creation of the image.
	NVG_IMAGE_REPEATX			= 1<<1,		// Repeat image in X direction.
	NVG_IMAGE_REPEATY			= 1<<2,		// Repeat image in Y direction.
	NVG_IMAGE_FLIPY				= 1<<3,		// Flips (inverses) image in Y direction when rendered.
	NVG_IMAGE_PREMULTIPLIED		= 1<<4;		// Image data has premultiplied alpha.

// Init
xptr nvg_Init(int flags) {} // Returns NanoVG context used in other functions.
void nvg_SetContext(xptr context) {}
void nvg_Finish(xptr context) {}
int nvg_SetViewport(xptr context) {} // Returns 1 if changed viewport, 0 otherwise.

// Drawing
void nvg_BeginFrame() {}
void nvg_CancelFrame() {}
void nvg_EndFrame() {}

// Global composite operation
void nvg_GlobalCompositeOperation(int op) {}
void nvg_GlobalCompositeBlendFunc(int sfactor, int dfactor) {}
void nvg_GlobalCompositeBlendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {}

// State handling
void nvg_Save() {}
void nvg_Restore() {}
void nvg_Reset() {}

// Render styles
void nvg_StrokeColor(float r, float g, float b, float a) {}
void nvg_StrokePaint(xptr paint) {} // paint - result of Paints functions
void nvg_FillColor(float r, float g, float b, float a) {}
void nvg_FillPaint(xptr paint) {} // paint - result of Paints functions
void nvg_MiterLimit(float limit) {}
void nvg_StrokeWidth(float size) {}
void nvg_LineCap(int cap) {}
void nvg_LineJoin(int join) {}
void nvg_GlobalAlpha(float alpha) {}

// Transformations
void nvg_ResetTransform() {}
void nvg_Transform(float a, float b, float c, float d, float e, float f) {}
void nvg_Translate(float x, float y) {}
void nvg_Rotate(float angle) {}
void nvg_SkewX(float angle) {}
void nvg_SkewY(float angle) {}
void nvg_Scale(float x, float y) {}

// Images
int nvg_CreateImage(string filename, int imageFlags) {}
int nvg_CreateImageMem(int imageFlags, xptr data, int ndata) {}
int nvg_CreateImageRGBA(int w, int h, int imageFlags, xptr data) {}
void nvg_UpdateImage(int image, xptr data) {}
void nvg_ImageSize(int image, ref int w, ref int h) {}
void nvg_DeleteImage(int image) {}

// Paints
xptr nvg_LinearGradient(float sx, float sy, float ex, float ey,
	float ir, float ig, float ib, float ia,
	float or, float og, float ob, float oa) {}
xptr nvg_BoxGradient(float x, float y, float w, float h, float r, float f,
	float ir, float ig, float ib, float ia,
	float or, float og, float ob, float oa) {}
xptr nvg_RadialGradient(float cx, float cy, float inr, float outr,
	float ir, float ig, float ib, float ia,
	float or, float og, float ob, float oa) {}
xptr nvg_ImagePattern(float ox, float oy, float ex, float ey,
	float angle, int image, float alpha) {}
void nvg_FreePaint(xptr paint) {}

// Scissoring
void nvg_Scissor(float x, float y, float w, float h) {}
void nvg_IntersectScissor(float x, float y, float w, float h) {}
void nvg_ResetScissor() {}

// Paths
void nvg_BeginPath() {}
void nvg_MoveTo(float x, float y) {}
void nvg_LineTo(float x, float y) {}
void nvg_BezierTo(float c1x, float c1y, float c2x, float c2y, float x, float y) {}
void nvg_QuadTo(float cx, float cy, float x, float y) {}
void nvg_ArcTo(float x1, float y1, float x2, float y2, float radius) {}
void nvg_ClosePath() {}
void nvg_PathWinding(int dir) {}
void nvg_Arc(float cx, float cy, float r, float a0, float a1, int dir) {}
void nvg_Rect(float x, float y, float w, float h) {}
void nvg_RoundedRect(float x, float y, float w, float h, float r) {}
void nvg_RoundedRectVarying(float x, float y, float w, float h,
	float radTopLeft, float radTopRight, float radBottomRight, float radBottomLeft) {}
void nvg_Ellipse(float cx, float cy, float rx, float ry) {}
void nvg_Circle(float cx, float cy, float r) {}
void nvg_Fill() {}
void nvg_Stroke() {}
void nvg_StrokeNoScale() {}

// Text
int nvg_CreateFont(string name, string filename) {}
int nvg_CreateFontMem(string name, xptr data, int ndata, int freeData) {}
int nvg_FindFont(string name) {}
int nvg_AddFallbackFontId(int baseFont, int fallbackFont) {}
int nvg_AddFallbackFont(string baseFont, string fallbackFont) {}
void nvg_FontSize(float size) {}
void nvg_FontBlur(float blur) {}
void nvg_TextLetterSpacing(float spacing) {}
void nvg_TextLineHeight(float lineHeight) {}
void nvg_TextAlign(int align) {}
void nvg_FontFaceId(int font) {}
void nvg_FontFace(string font) {}
void nvg_Text(float x, float y, string str, string end) {}
void nvg_TextBox(float x, float y, float breakRowWidth, string str, string end) {}
float nvg_TextBounds(float x, float y, string str, string end, ref vec4 bounds) {}
void nvg_TextBoxBounds(float x, float y, float breakRowWidth, string str, string end, vec4 bounds) {}
void nvg_TextMetrics(ref float ascender, ref float descender, ref float lineh) {}

// SVG support
xptr nsvg_ParseFromFile(string filename, string units, float dpi) {}
xptr nsvg_ParseMem(string data, int ndata, string units, float dpi) {}
void nsvg_ImageSize(xptr image, ref float width, ref float height) {}
int nsvg_ImageShapeCount(xptr image, string shapeIdPrefix) {}
void nsvg_Draw(xptr image, string shapeIdPrefix,
  int strokeWidthScaling, float strokeWidthFactor, float buildUpFromFactor, float buildUpToFactor, xptr color) {}
void nsvg_Rasterize(xptr image, float tx, float ty, float scale, xptr dst, int w, int h) {}
void nsvg_Delete(xptr image) {}]]>
      </Source>
    </ZExternalLibrary>
    <ZExternalLibrary ModuleName="ZGameEditor Visualizer">
      <Source>
<![CDATA[// ZGameEditor Visualizer built-in functions

void ParamsWriteValueForLayer(xptr Handle, int Layer,int Param, float NewValue) { }
void ParamsUpdateComboItems(xptr Handle, int Layer,int Param, string[] NewItems) { }
int ReadPrivateData(xptr Handle, xptr Data, int Size) { }
void WritePrivateData(xptr Handle, xptr Data, int Size) { }
void ZgeVizGetFileNames(string path, string pattern, string[] list) { }
void ZgeVizFontGetContent(string FileName,ref xptr ContentMem, ref int ContentSize) { }]]>
      </Source>
    </ZExternalLibrary>
    <ZLibrary Comment="HSV conversion by Kjell">
      <Source>
<![CDATA[float angle(float X)
{
  if(X >= 0 && X < 360)return X;
  if(X > 360)return X-floor(X/360)* 360;
  if(X <   0)return X+floor(X/360)*-360;
}

void hsv(float H, float S, float V, ref vec4 c)
{
  float R,G,B,I,F,P,Q,T;

  H = angle(H);
  S = clamp(S,0,100);
  V = clamp(V,0,100);

  H /= 60;
  S /= 100;
  V /= 100;

  if(S == 0)
  {
    c.R = V;
    c.G = V;
    c.B = V;
    return;
  }

  I = floor(H);
  F = H-I;

  P = V*(1-S);
  Q = V*(1-S*F);
  T = V*(1-S*(1-F));

  if(I == 0){R = V; G = T; B = P;}
  if(I == 1){R = Q; G = V; B = P;}
  if(I == 2){R = P; G = V; B = T;}
  if(I == 3){R = P; G = Q; B = V;}
  if(I == 4){R = T; G = P; B = V;}
  if(I == 5){R = V; G = P; B = Q;}

  c.R = R;
  c.G = G;
  c.B = B;
}]]>
      </Source>
    </ZLibrary>
    <ZLibrary Comment="Effect interface">
      <Source>
<![CDATA[const string AuthorInfo = "Impostorem\nhttp://www.impostorem.com\nBased on Rado1's ZgeNano library and HUD Text";

// PARAMETERS

const string ParamHelpConst =
"Alpha\n" +
"Hue\n" +
"Saturation\n" +
"Lightness\n" +
"Position X\n" +
"Position Y\n" +
"Rotation\n" +
"Text line\n" +
"Font @list1000:\n" +
"Font size\n" +
"Letter spacing\n" +
"Enable FX @checkbox\n" +
"FX per @list: Line, Word, Letter\n" +
"Attack FX @list1000: None,Fade,Blur,Expander, Vertical\n" +
" Length\n" +
"Hold FX @list1000: None\n" +
" Length\n" +
"Release FX @list1000: None,Fade,Blur,Expander,Vertical\n" +
" Length\n" +
"Beat FX @list1000: None,Fade,Blur,Expander\n" +
"# lines @list: 1,2\n" +
"Beat Strength\n" +
"Beat Wave @list: Saw,1-Saw, Sin, 1-Sin\n";


const int
  P_ALPHA = 0,
  P_HUE = 1,
  P_SATURATION = 2,
  P_LIGHTNESS = 3,
  P_POSITION_X = 4,
  P_POSITION_Y = 5,
  P_ROTATION = 6,
  P_TEXT_LINE = 7,
  P_FONT = 8,
  P_FONT_SIZE = 9,
  P_LETTER_SPACING = 10,
  P_ENABLE_FX = 11,
  P_EFFECT_PER = 12,
  P_ATTACK_FX = 13,
  P_ATTACK_LEN = 14,
  P_HOLD_FX = 15,
  P_HOLD_LEN = 16,
  P_RELEASE_FX = 17,
  P_RELEASE_LEN = 18,
  P_BEAT_FX = 19,
  P_NUM_LINES = 20,
  P_STRENGTH = 21,
  P_WAVE = 22,
  NUM_OF_PARAMS = 23;

const int
  NUM_ATTACK_FX_TYPES = 5,
  NUM_HOLD_FX_TYPES = 1,
  NUM_RELEASE_FX_TYPES = 5,
  NUM_BEAT_FX_TYPES = 4,
  NUM_WAVE_TYPES = 4;

// VARIABLES

xptr FLPluginHandle;
int LayerNr;
string FLPluginPath;
string[0] UserTextArray;
int FLShowEditor;
float FLGraphicsScaleFactor;

float[NUM_OF_PARAMS] ParamOld;
int[NUM_OF_PARAMS] ParamChanged;
vec4 Color;

int[NUM_ATTACK_FX_TYPES]  AttackFXTypes;
int[NUM_HOLD_FX_TYPES]    HoldFXTypes;
int[NUM_RELEASE_FX_TYPES] ReleaseFXTypes;
int[NUM_BEAT_FX_TYPES]    BeatFXTypes;]]>
      </Source>
    </ZLibrary>
    <ZLibrary Comment="Globals">
      <Source>
<![CDATA[// CONSTANTS

// determines processing mode flag for OnHostMessage
private const int FPD_ProcessMode = 1;

// boolean
const int FALSE = 0;
const int TRUE = 1;

const float PI2 = PI * 2.0;

// VARIABLES

xptr NvgContext;
string FontDir;
float ViewportWidth, ViewportHeight, AspectRatio;
float
  PosX,
  PosY,
  Rotation,
  PlaceValueMultiplier,
  FontSize,
  RowWidth,
  LineHeight,
  LetterSpacing;

int
  CurrentFont,
  AlignHoriz,
  AlignVert;

string Text;
string PrevText;
int PrevTextLine;
int CurTextLine;
int TextChanged;
float LastTextUpdate; // in appTime
float LastTextBeat;   // in beats

float UpdatePosition; // hmmm....

// FX sequence
const int
  FX_BYPASS = 0,   // Text is drawn, but no effects.
  FX_ATTACK = 1,   // First portion
  FX_HOLD = 2,     // Middle portion
  FX_RELEASE = 3,  // End portion
  FX_BEAT = 4,     // During all sequences but none
  FX_NONE = 5;     // Sequence completed, nothing drawn.

// FX type
const int
  FX_TYPE_NONE = 0,
  FX_TYPE_FADE = 1,
  FX_TYPE_BLUR = 2,
  FX_TYPE_EXPANDER = 3,
  FX_TYPE_VERTICAL = 4;

const int WAVE_SAW = 0,
          WAVE_SAW_1 = 1,
          WAVE_SIN = 2,
          WAVE_SIN_1 = 3;

int   FXType;     // FX_TYPE_NONE, FX_TYPE_FADE, etc.
int   FXSequence; // FX_BYPASS/FX_ATTACK/FX_HOLD, etc.
float FXPosition; // Where are we in current sequence?
float FXStrength;
float FadeAlpha;
float VerticalSlide; // Fade in/out vertically - 0-1
int FontId;
float Blur;

// font TTF files
string[0] FontFiles;

// FUNCTIONS
inline float distSigned(float a, float b) {
  return sqrt(a*a + b*b) * (a + b > 0 ? 1 : -1);
}

inline int max(int a, int b) {
  return a > b ? a : b;
}

// callback on hanged OpenGL context
void OnGLContextChange() {
  // reset NanoVG
  @CallComponent(Component: InitNanoVG);
}

// Callback on writing private data to effect level; called on project saving.
void OnWritePrivateData() {
  byte[256] name;
  string s = FontFiles[CurrentFont];

  // copy file name to array
  name[length(s)] = 0;
  for(int i = length(s) - 1; i >= 0; --i)
    name[i] = ord(substr(s, i, 1));

  // write array
  WritePrivateData(FLPluginHandle, name, 256);
}

// Callback on reading private data to effect level; called on project loading.
void OnReadPrivateData() {
  byte[256] name;
  string s;

  // read array
  int read = ReadPrivateData(FLPluginHandle, name, 256);
  if (read == 0) return;

  // copy to string
  s = "";
  int hasExtension=0;
  for(int i = 0; name[i] != 0; ++i) {
    string onechar=chr(name[i]);
    if(onechar==".")
      hasExtension=1;
    s = s + onechar;
  }
  if(!hasExtension)
    //If project was saved before file extensions were added then default to ".ttf"
    s=s+".ttf";

  for (int i = FontFiles.SizeDim1 - 1; i >= 0; --i)
    if (FontFiles[i] == s) {
      ParamsWriteValueForLayer(FLPluginHandle, LayerNr, P_FONT, i / 1000.0);
      break;
    }
}

// Callback to handle external messages
void OnHostMessage(int id, int index, int value)
{
  if(id == FPD_ProcessMode)
  {
    if (value & 16)
    {
      // video rendering
    } else
    {
      // return from rendering
    }
  }
}

// reading fonts and setting the combo box
void InitFonts()
{
  if (MACOS)
    FontDir = FLPluginPath + "Effects/HUD/fonts/";
  else
    FontDir = FLPluginPath + "Effects\\HUD\\fonts\\";

  ZgeVizGetFileNames(FontDir, "*.ttf;*.zfo", FontFiles);

  // prepare font names without file extension
  string[0] names;
  names.SizeDim1 = FontFiles.SizeDim1;
  for (int i = names.SizeDim1 - 1; i >= 0; --i)
    names[i] = subStr(FontFiles[i], 0, length(FontFiles[i])-4);

  ParamsUpdateComboItems(FLPluginHandle, LayerNr, P_FONT, names);
}

// recompute all parameters
void ResetOldParameters()
{
  for(int i = 0; i < NUM_OF_PARAMS; ++i)
    ParamOld[i] = -1;
}]]>
      </Source>
    </ZLibrary>
    <ZLibrary Name="Effects">
      <Source>
<![CDATA[// Returns 0-1, where 0 is on the beat
float beatPos()
{
  int posBeats = SongPositionInBeats;
  return SongPositionInBeats - posBeats;
}

float beatMul()
{
  int   wave = Parameters[P_WAVE] * NUM_WAVE_TYPES;
  float waveVal = 1.0;

  switch  (wave)
  {
    case WAVE_SAW:
       waveVal = beatPos();
       break;
    case WAVE_SAW_1:
       waveVal = 1.0 - beatPos();
       break;
    case WAVE_SIN:
       waveVal = sin(beatPos()*PI);
       break;
    case WAVE_SIN_1:
       waveVal = 1.0 - sin(beatPos()*PI);
       break;
  }
  return abs(waveVal * FXStrength);
}

// Returns alpha multiplier given sequence and position
float FadeEffect(int sequence, float position)
{
  float alphaMul = 1.0;
  // Fade effect
  switch (sequence)
  {
    case FX_ATTACK:
      alphaMul = position;
      break;
    case FX_HOLD:
      break;
    case FX_BEAT:
      alphaMul = 1.0 - position;
      break;
    case FX_RELEASE:
      alphaMul = 1.0 - position;
      break;
    case FX_BYPASS:
      break;
    case FX_NONE:
      break;
  }
  return alphaMul;
}

float BlurEffect(int sequence, float position)
{
  float blurMul = 0;
  switch (sequence)
  {
    case FX_ATTACK:
      blurMul = 1.0 - position;
      break;
    case FX_HOLD:
      break;
    case FX_BEAT:
      blurMul = position;
      break;
    case FX_RELEASE:
      blurMul = position;
      break;
    case FX_BYPASS:
      break;
    case FX_NONE:
      break;
  }
  return blurMul;
}

float ExpanderEffect(int sequence, float position)
{
  float expander = LetterSpacing;
  switch (sequence)
  {
    case FX_ATTACK:
      expander = LetterSpacing + FontSize*(1.0 - position);
      break;
    case FX_HOLD:
      break;
    case FX_BEAT:
      expander = LetterSpacing + FontSize*(position);
      break;
    case FX_RELEASE:
      expander = LetterSpacing + FontSize*(position);
      break;
    case FX_BYPASS:
      break;
    case FX_NONE:
      break;
  }
  return expander;
}

float VerticalEffect(int sequence, float position)
{
  float slide = 0;
  switch (sequence)
  {
    case FX_ATTACK:
      slide = LineHeight - position*LineHeight;
      break;
    case FX_RELEASE:
      slide = position*LineHeight;
      break;

    case FX_HOLD:
    case FX_BEAT:
    case FX_BYPASS:
    case FX_NONE:
      break;
  }
  trace("Vert:" + intToStr(slide*1000) + " LineH:" + intToStr(LineHeight));
  return slide;
}]]>
      </Source>
    </ZLibrary>
    <ZExpression Comment="Init">
      <Expression>
<![CDATA[setRandomSeed(getSystemTime());

InitFonts();
ResetOldParameters();

// Initialize text changes
PrevTextLine   = 0;
CurTextLine    = 0;
PrevText       = "";
Text           = "";
LastTextUpdate = 0.0;
TextChanged    = 0;

// Hmmm... best way to init these? They must match EffectsInterface
// lists and map the menu item to the FX type defined in Globals.
AttackFXTypes[0]  = FX_TYPE_NONE;
AttackFXTypes[1]  = FX_TYPE_FADE;
AttackFXTypes[2]  = FX_TYPE_BLUR;
AttackFXTypes[3]  = FX_TYPE_EXPANDER;
AttackFXTypes[4]  = FX_TYPE_VERTICAL;

HoldFXTypes[0]  = FX_TYPE_NONE;

ReleaseFXTypes[0] = FX_TYPE_NONE;
ReleaseFXTypes[1] = FX_TYPE_FADE;
ReleaseFXTypes[2] = FX_TYPE_BLUR;
ReleaseFXTypes[3] = FX_TYPE_EXPANDER;
ReleaseFXTypes[4] = FX_TYPE_VERTICAL;

BeatFXTypes[0] = FX_TYPE_NONE;
BeatFXTypes[1] = FX_TYPE_FADE;
BeatFXTypes[2] = FX_TYPE_BLUR;
BeatFXTypes[3] = FX_TYPE_EXPANDER;]]>
      </Expression>
    </ZExpression>
    <ZExpression Name="InitNanoVG">
      <Expression>
<![CDATA[// init NanoVG
NvgContext = nvg_Init(NVG_STENCIL_STROKES);
if (NvgContext == null) {
  trace("Error to init NanoVG.");
  quit();
}
// enforce recomputing viewport size and font reloading
ViewportWidth = -1;]]>
      </Expression>
    </ZExpression>
    <SetAppState State="MainAppState"/>
  </OnLoaded>
  <States>
    <AppState Name="MainAppState" CollisionsEnabled="0">
      <OnUpdate>
        <Condition Expression="return App.ViewportWidth != 0;">
          <OnTrue>
            <ZExpression/>
            <ZExpression Comment="Compute shape parameters">
              <Expression>
<![CDATA[// Rado1's update code from HUD Text, with
// various parts removed.

xptr cont;
int s = FALSE, f = FALSE; // flags of changing size, text or font

// reload font if NVG context has changed
if (ViewportWidth == -1) {
  f = TRUE;
}

// resize if viewport has changed
if (nvg_SetViewport(NvgContext))
{
  ViewportWidth = App.ViewportWidth;
  ViewportHeight = App.ViewportHeight;
  AspectRatio = ViewportWidth / ViewportHeight;
  s = TRUE;
}


// update parameter change
for(int i = 0; i < NUM_OF_PARAMS; ++i) {
  ParamChanged[i] = Parameters[i] != ParamOld[i];
  if (ParamChanged[i])
    ParamOld[i] = Parameters[i];
}

// check changed parameters

// update color
if (ParamChanged[P_HUE] || ParamChanged[P_SATURATION] || ParamChanged[P_LIGHTNESS] ||
  ParamChanged[P_ALPHA])

  hsv(Parameters[P_HUE]*360,Parameters[P_SATURATION]*100,(1-Parameters[P_LIGHTNESS])*100, Color);
  Color.A = 1 - Parameters[P_ALPHA];

// position X
if (ParamChanged[P_POSITION_X] || s)
  PosX = Parameters[P_POSITION_X] * ViewportWidth;

// position Y
if (ParamChanged[P_POSITION_Y] || s)
  PosY = Parameters[P_POSITION_Y] * ViewportHeight;

// rotation
if (ParamChanged[P_ROTATION])
  Rotation = (Parameters[P_ROTATION] - 0.5) * PI2;

// font
if (ParamChanged[P_FONT] || f) {

  CurrentFont = round(Parameters[P_FONT] * 1000);
  string fn = FontFiles[CurrentFont];

  // load font
  FontId = nvg_FindFont(fn);
  if (FontId < 0) {
    xptr contentMem;
    int contentSize;
    ZgeVizFontGetContent(FontDir + fn,contentMem, contentSize);
    FontId = nvg_CreateFontMem(fn, contentMem, contentSize, 0);
  }
}

// font size
if (ParamChanged[P_FONT_SIZE] || s) {
  FontSize = Parameters[P_FONT_SIZE] * Parameters[P_FONT_SIZE] * ViewportHeight;
  s = TRUE;
}

// letter spacing
if (ParamChanged[P_LETTER_SPACING] || s)
  LetterSpacing = (Parameters[P_LETTER_SPACING] - 0.5) * FontSize * 2.0;

// Effects may play with these.
Blur = 0;
AlignHoriz = NVG_ALIGN_CENTER;
AlignVert  = NVG_ALIGN_MIDDLE;

float ascender, descender;
nvg_TextMetrics(ascender,descender,LineHeight);]]>
              </Expression>
            </ZExpression>
            <ZExpression Name="TextUpdate">
              <Expression>
<![CDATA[FXStrength = Parameters[P_STRENGTH];

// Update text and timer
int newTextLine = round(Parameters[P_TEXT_LINE] * (UserTextArray.SizeDim1-1));
if (CurTextLine != newTextLine)
{
  PrevTextLine = CurTextLine;
  CurTextLine = newTextLine;
  PrevText = Text;

  LastTextUpdate = App.Time;
  LastTextBeat = SongPositionInBeats;

  UpdatePosition = 0;
  TextChanged = 1;
}
else
{
//  UpdatePosition = App.Time - LastTextUpdate;
  UpdatePosition = SongPositionInBeats - LastTextBeat;
}

// If we changed fx enable, restart it.
if (ParamChanged[P_ENABLE_FX])
{
  LastTextUpdate = App.Time;
  LastTextBeat = SongPositionInBeats;

  trace("FX Enable change");
  UpdatePosition = 0;
}

Text = UserTextArray.SizeDim1 > 0
  ? UserTextArray[CurTextLine]
  : "";
if (Length(Text) & 1)
{
  Text += " ";
}


// Probably want to scale these to 5 seconds or so.
float FXScale    = 16;
float AttackLen  = Parameters[P_ATTACK_LEN] * 4;
float HoldLen    = Parameters[P_HOLD_LEN]   * FXScale;
float ReleaseLen = Parameters[P_RELEASE_LEN]* 4;

FXPosition = 0.0;
FXSequence = FX_NONE;

// Do Transition FX....

// Get our position within effect and effect type
if (UpdatePosition < AttackLen)
{
  FXPosition = (UpdatePosition) / AttackLen;
  FXSequence = FX_ATTACK;
  int attackIndex = Parameters[P_ATTACK_FX] * 1000;
  FXType = AttackFXTypes[attackIndex];
}
else if (UpdatePosition < AttackLen + HoldLen)
{
  FXPosition = (UpdatePosition - AttackLen)  / HoldLen;
  FXSequence = FX_HOLD;
  int holdIndex = Parameters[P_HOLD_FX] * 1000;
  FXType = HoldFXTypes[holdIndex];
}
else if (UpdatePosition < AttackLen + HoldLen + ReleaseLen)
{
  FXPosition = (UpdatePosition - (AttackLen + HoldLen)) / ReleaseLen;
  FXSequence = FX_RELEASE;
  int releaseIndex = Parameters[P_RELEASE_FX] * 1000;
  FXType = ReleaseFXTypes[releaseIndex];
}

if (Parameters[P_ENABLE_FX] < 0.5)
{
  FXSequence = FX_HOLD;
  int holdIndex = Parameters[P_HOLD_FX] * 1000;
  FXType = HoldFXTypes[holdIndex];
  FXPosition = 0;
}

// Setup the effects here
// Rendering is another step
FadeAlpha = 1.0;
Blur = 0;
LetterSpacing = (Parameters[P_LETTER_SPACING] - 0.5) * FontSize * 2.0;
VerticalSlide = 0;

switch (FXType)
{
  case FX_TYPE_NONE:
    break;
  case FX_TYPE_FADE:
    FadeAlpha = FadeEffect(FXSequence, FXPosition);
    break;
  case FX_TYPE_BLUR:
    Blur = BlurEffect(FXSequence, FXPosition)*20;
    break;
  case FX_TYPE_EXPANDER:
    LetterSpacing = ExpanderEffect(FXSequence, FXPosition);
    break;
  case FX_TYPE_VERTICAL:
    VerticalSlide = VerticalEffect(FXSequence, FXPosition);
    break;
}

// If fade transitions...
if ((FXSequence == FX_ATTACK) || (FXSequence == FX_RELEASE))
{
    if ((FX_TYPE_FADE != FXType) && (FX_TYPE_NONE != FXTYPE))
    {
      FadeAlpha = FadeEffect(FXSequence, FXPosition);
    }
}


// Add in beat FX
if (FX_NONE != FXSequence)
{
  switch (Parameters[P_BEAT_FX]*1000)
  {
    case FX_TYPE_NONE:
      break;
    case FX_TYPE_FADE:
      FadeAlpha *= FadeEffect(FX_BEAT, beatMul());
      break;
    case FX_TYPE_BLUR:
      Blur += BlurEffect(FX_BEAT, beatMul())*20;
      break;
    case FX_TYPE_EXPANDER:
      LetterSpacing += ExpanderEffect(FX_BEAT, beatMul());
      break;
  }
}]]>
              </Expression>
            </ZExpression>
          </OnTrue>
        </Condition>
      </OnUpdate>
      <OnRender>
        <ZExpression>
          <Expression>
<![CDATA[nvg_SetContext(NvgContext);

//Text

if (FXSequence != FX_NONE)
{
  nvg_BeginFrame();

  nvg_FontFaceId(FontId);
  nvg_TextAlign(AlignHoriz | AlignVert);
  nvg_FontSize(FontSize);
  nvg_FillColor(Color.R, Color.G, Color.B, Color.A * FadeAlpha);
  nvg_FontBlur(Blur);
  nvg_Scissor(0, PosY - LineHeight/2, App.ViewportWidth, LineHeight);

  nvg_Translate(PosX, PosY + VerticalSlide);
  nvg_Rotate(Rotation);
  nvg_TextLetterSpacing(LetterSpacing);
  nvg_Text(0, 0, Text, null);

  nvg_ResetScissor();
  nvg_EndFrame();
}]]>
          </Expression>
        </ZExpression>
      </OnRender>
    </AppState>
  </States>
  <OnClose>
    <ZExpression Name="FinishNanoVG">
      <Expression>
<![CDATA[nvg_SetContext(NvgContext);
nvg_Finish(NvgContext);]]>
      </Expression>
    </ZExpression>
  </OnClose>
  <Content>
    <Array Name="Parameters" SizeDim1="26" Persistent="255">
      <Values>
<![CDATA[789C636000037B0604B047C260306BE64C3B647EBE10B3F5D933676C97CD76B10689C3F8201AA2A2C18E010D00006D580D84]]>
      </Values>
    </Array>
    <Array Name="SpecBandArray"/>
    <Material Name="Material1">
      <Textures>
        <MaterialTexture Name="FLEditorMaterialTexture"/>
      </Textures>
    </Material>
    <Array Name="AudioArray"/>
    <Variable Name="SongPositionInBeats"/>
  </Content>
</ZApplication>
